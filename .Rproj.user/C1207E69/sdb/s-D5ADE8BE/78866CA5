{
    "collab_server" : "",
    "contents" : "###############################################################################\n## Exemplo do capítulo sobre EVT de medidas condicionais de risco utilizando\n## o método processo pontual auto-excitavel.\n## Dados da GS entre 05/05/1999 a 04/10/2016\n###############################################################################\nlibrary(xts)\nlibrary(PerformanceAnalytics)\nlibrary(xtable)\nlibrary(PtProcess)\nlibrary(fExtremes)\nlibrary(gPdtest)\nlibrary(plotly)\n\nsetwd(\"C:\\\\Users\\\\Rafael\\\\Documents\\\\UDESC\\\\TCC\\\\TCC Latex svn\\\\TCC-R-codes\")\n\nprices <- as.xts(read.zoo(read.csv(\"evt-exemplo GS.csv\"), format = \"%Y-%m-%d\", FUN = as.Date))\nreturns <- na.omit(Return.calculate(prices, method = \"log\"))\nlosses <- -1*returns\nlosses <- losses[,\"Adj.Close\"]\nnames(losses) <- \"losses\"\n#############################################################################################################\n## Pode-se usar os pacotes PtProcess (mais geral) ou SAPP (função etasap)\n## Utilizando o pacote PtProcess\n## Definindo o modelo de processo pontual marcado - mpp\n## Nosso modelo sera um ETAS e a distribuição das marcas uma distribuicao de Pareto com qsi > 0\n#############################################################################################################\n# Quero um DF com tempos e valores de perdas acima de u=1.5%\nu <- quantile(losses, 0.9)\nLu <- losses[which(losses[,\"losses\"]>u),\"losses\"]\nTj <- as.numeric(index(Lu)-index(losses[1,]))\nLj <- coredata(Lu) # Eh o valor original da perda, dado que ela seja maior que u\nLuj <- Lj - u # Eh a perda em excesso, que sera a entrada para as densidades lambdag e dgP_mark\nDatadf <- data.frame(Luj, time = Tj/365) # tem que ajustar o nome da coluna de Luj\ncolnames(Datadf)[1] <- \"magnitude\"\n#Ht <- data.frame(time=as.numeric(index(losses)-index(losses[1,])), magnitude=coredata(losses[,\"Adj.Close\"]))# tem que ajustar o nome da coluna\n#colnames(Ht)[2] <- \"magnitude\"\n#evalpts <- Ht[,\"time\"] # valores onde sera avaliada a funcao intensidade\nplot(Datadf$time, Datadf$magnitude, type=\"h\")\n#############################################################################################################\n## Vamos primeiro estimar os parametros da GPD\ngpd <- gpdFit(as.timeSeries(losses[,\"losses\"]), u=u, type = \"mle\")\nxi <- gpd@fit$par.ests[1]\nbeta <- gpd@fit$par.ests[2]\n#############################################################################################################\n## Agora que ja temos o DF de dados e os pontos de avaliacao, temos de especificar o modelo MPP\n## A funcao intensidade de base (lambdag) sabemos que será uma ETAS\n## A densidade das marcas eh uma GPD com parametros qsi e beta\n## Precisamos especificar as funcoes densidade e simulacao das marcas, dgP_mark e rgP_mark\n## o vetor de parametros contem TODOS os parametros das duas densidades, sendo os primeiros\n## pertencentes ao modelo ETAS (5), apos vem os parametros da GPD (2), Logo\n## params = mu, A, alpha, c, p, xi, beta\n\n#############################################################################################################\ndgP_mark <- function(x, data, params){\n  g <- (1/beta)*(1+((xi*x[,\"magnitude\"])/beta))^(-1-(1/xi))\n  return(log(g))\n}\n\nrgP_mark <- function(ti, data, params){\n  y <- rgp(1, beta, xi)\n  return(list(magnitude = y))\n}\n#############################################################################################################\n## Mapeamento dos parametros\ngmap <- expression(params[1:5])\n#mmap <- expression(params)\n## Mapeamento para o otimizador\nnlmmap <- function(y, p){\n  y$params <- p\n  return(y)\n}\nexpmap <- function(y, p){\n  y$params <- exp(p)\n  return(y)\n}\n## O objeto MPP propriamente dito\nDados <- Datadf\n#Dados$magnitude <- Dados$magnitude - 4.95 # Apenas quando for Phuket\nparameters <- c(0.05, 3.1, 1.5, 0.1, 1.1) # Valores iniciais dos parametros para lambdag\nTT <- c(Dados$time[1], Dados$time[nrow(Dados)])\nsepp <- mpp(data = Dados, gif = etas_gif, marks = list(dgP_mark, rgP_mark),\n            params = parameters, gmap = gmap, mmap = NULL, TT = TT)\n\n## Como os parametros do modelo devem ser todos positivos, podemos tirar o log deles e passar\n## para o otimizador para que este trabalhe com todos os reais\ninitial <- log(parameters)\n## A funcao negativa logaritimica de verossimilhanca negloglik deve ser minimizada\n# Utilizar dois passos. Primeiro optim e depois nlm\nsepphat <- optim(initial, neglogLik, gr = NULL, object = sepp, pmap = expmap,\n                 control = list(trace = 1, maxit = 100))\nif(sepphat$convergence == 0){\n  # Então a convergencia foi bem sucedida\n  seppmodel <- expmap(sepp, sepphat$par)\n}else{\n  # Agora pode-se usar os parametros estimados para serem valores iniciais de uma nova otimizacao\n  initial <- sepphat$par\n  sepphat <- nlm(neglogLik, initial, object = sepp, pmap = expmap,\n                 print.level = 2, iterlim = 500, typsize = initial)\n  seppmodel <- expmap(sepp, sepphat$estimate)\n}\n\n## Dado a convergencia do modelo podemos plotar a funcao intensidade de base\npts <- seq(0, as.numeric(index(losses[nrow(losses),])-index(losses[1,]))/365,\n           length.out = nrow(losses))\nlambdag <- etas_gif(Dados, evalpts = pts, params = seppmodel$params)/365\nexc <- (losses[,\"losses\"]-u)-((losses[,\"losses\"]-u)<0)*(losses[,\"losses\"]-u)\nts <- cbind(losses, intensity = lambdag, exc)\nnames(ts)[3] <- \"excess\"\nop <- par(mfrow=c(2,1))\nplot(ts[,\"intensity\"], xlab = \"\", ylab = \"Intensidade\",\n     main = \"Processo Pontual de Auto-Excitação\", major.format=\"%m/%Y\")\nplot(ts[,\"excess\"], type=\"h\", xlab = \"Data\", ylab = \"Perdas em excesso\",\n     main = \"\", major.format=\"%m/%Y\")\npar(op)\nseppmodel$params\n# Plotly\nplot_ly(x=index(ts), y=coredata(ts[,\"intensity\"]))\n\n## Analise da adequacao do fit\nplot(residuals(seppmodel), xlab = \"Evento Número\", ylab = \"Tempo Transformado\", pty = \"s\")\n\n# Vetor theta com os parametros conforme modelo na monografia\ntheta <- with(seppmodel, c(params[1], params[2]*params[4]^params[5], params[3], params[4], params[5]-1,\n                           params[6], params[7]))\n",
    "created" : 1475708532481.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3395695790",
    "id" : "78866CA5",
    "lastKnownWriteTime" : 1475781185,
    "last_content_update" : -2147483648,
    "path" : "~/UDESC/TCC/TCC Latex svn/TCC-R-codes/evt-exemplo GS2.R",
    "project_path" : "evt-exemplo GS2.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}